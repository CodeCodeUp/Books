# 图书馆资源智能化推荐系统设计文档

## 项目概述
基于协同过滤与内容特征的图书馆资源智能化推荐系统，采用SpringBoot + Vue技术栈实现，算法部分使用Python实现。

**开发策略**: 优先开发Web系统基础功能，后续集成推荐算法，确保项目渐进式交付。

## 系统架构设计

### 1. 整体架构（已实现）
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Vue.js前端    │    │ SpringBoot后端  │    │   MySQL数据库   │
│                 │◄──►│                 │◄──►│                 │
│ - 用户界面      │    │ - RESTful API   │    │ - 业务数据      │
│ - 图书展示      │    │ - 业务逻辑      │    │ - 用户信息      │
│ - 推荐结果      │    │ - 数据管理      │    │ - 评分记录      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                       ┌─────────────────┐
                       │  Python算法服务  │ ✅
                       │                 │
                       │ - 用户协同过滤   │ ✅
                       │ - 物品协同过滤   │ ✅  
                       │ - 智能缓存      │ ✅
                       └─────────────────┘
```

### 2. 技术栈选择（已实现）
- **前端**: Vue 3 + Element Plus + Pinia + Vue Router ✅
- **后端**: SpringBoot 3.1 + Spring Security + MyBatis Plus ✅
- **数据库**: MySQL 8.0 + 专业版本管理 ✅
- **推荐算法**: Python Flask + NumPy + Pandas + Scikit-learn ✅
- **部署**: 本地开发环境

## 数据库设计

### 1. 核心数据表
详细设计见 `docs/数据库设计文档.md`

**主要数据表**:
- `users` - 用户基本信息（含登录认证）
- `books` - 图书元数据  
- `ratings` - 用户评分记录
- `favorites` - 用户收藏
- `recommendations` - 推荐记录（算法阶段添加）

### 2. 数据连接信息
```
Host: 116.205.244.106:3306
Database: book_recommendation
Username: root
Password: 202358hjq
```

## SpringBoot后端设计（已实现）

### 1. 项目结构
```
book-recommendation-backend/
├── src/main/java/com/bookrs/recommendation/
│   ├── BookRecommendationApplication.java  # 启动类 ✅
│   ├── controller/                         # 控制器层 ✅
│   │   ├── UserController.java            # 用户管理API ✅
│   │   └── BookController.java            # 图书管理API ✅
│   ├── service/                           # 业务逻辑层 ✅
│   │   ├── UserService.java               # 用户服务 ✅
│   │   └── BookService.java               # 图书服务 ✅
│   ├── mapper/                            # 数据访问层 ✅
│   │   ├── UserMapper.java                # 用户数据访问 ✅
│   │   ├── BookMapper.java                # 图书数据访问 ✅
│   │   └── RatingMapper.java              # 评分数据访问 ✅
│   ├── entity/                            # 实体类 ✅
│   │   ├── User.java                      # 用户实体 ✅
│   │   ├── Book.java                      # 图书实体 ✅
│   │   └── Rating.java                    # 评分实体 ✅
│   ├── config/                            # 配置类 ✅
│   │   ├── MybatisPlusConfig.java         # 数据库配置 ✅
│   │   ├── SecurityConfig.java            # 安全配置 ✅
│   │   └── WebConfig.java                 # 跨域配置 ✅
│   └── common/                            # 通用组件 ✅
│       ├── Result.java                    # 统一返回结果 ✅
│       └── PageResult.java                # 分页结果 ✅
├── src/main/resources/
│   ├── application.yml                    # 应用配置 ✅
│   ├── mapper/BookMapper.xml              # MyBatis映射 ✅
│   └── db/                                # 数据库版本管理 ✅
│       ├── V1.0_Initial_Schema.sql        # 初始表结构
│       ├── V1.1_Remove_Foreign_Keys.sql   # 修复脚本
│       └── README.md                      # 版本说明
└── pom.xml                                # Maven依赖 ✅
```

### 2. 已实现的核心API

#### 用户管理API ✅
```java
@RestController
@RequestMapping("/users")
public class UserController {
    
    @PostMapping("/register")      // 用户注册 ✅
    @PostMapping("/login")         // 用户登录 ✅  
    @GetMapping("/{userId}")       // 获取用户信息 ✅
    @PutMapping("/{userId}")       // 更新用户信息 ✅
}
```

#### 图书管理API ✅
```java
@RestController  
@RequestMapping("/books")
public class BookController {
    
    @GetMapping                    // 分页查询图书 ✅
    @GetMapping("/{bookId}")       // 获取图书详情 ✅
    @GetMapping("/popular")        // 获取热门图书 ✅
    @GetMapping("/latest")         // 获取最新图书 ✅
}
```
    
    @PostMapping("/login") 
    public Result<LoginResponse> login(@RequestBody LoginRequest request);
    
    @GetMapping("/{userId}")
    public Result<UserDTO> getUserInfo(@PathVariable Integer userId);
    
    @PutMapping("/{userId}")
    public Result<Void> updateUserInfo(@PathVariable Integer userId, @RequestBody UserUpdateRequest request);
}
```

#### 图书管理API
```java
@RestController
@RequestMapping("/api/books")
public class BookController {
    
    @GetMapping
    public Result<PageResult<BookDTO>> getBooks(
        @RequestParam(defaultValue = "1") Integer page,
        @RequestParam(defaultValue = "20") Integer size,
        @RequestParam(required = false) String keyword);
    
    @GetMapping("/{bookId}")
    public Result<BookDetailDTO> getBookDetail(@PathVariable String bookId);
    
    @GetMapping("/search")
    public Result<PageResult<BookDTO>> searchBooks(@RequestParam String keyword);
    
    @GetMapping("/categories")
    public Result<List<String>> getCategories();
}
```

#### 评分管理API
```java
@RestController
@RequestMapping("/api/ratings")
public class RatingController {
    
    @PostMapping
    public Result<Void> addRating(@RequestBody RatingRequest request);
    
    @GetMapping("/user/{userId}")
    public Result<PageResult<RatingDTO>> getUserRatings(@PathVariable Integer userId);
    
    @GetMapping("/book/{bookId}")
    public Result<PageResult<RatingDTO>> getBookRatings(@PathVariable String bookId);
    
    @GetMapping("/book/{bookId}/stats")
    public Result<RatingStatsDTO> getBookRatingStats(@PathVariable String bookId);
}
```

#### 推荐API
```java
@RestController
@RequestMapping("/api/recommendations")
public class RecommendController {
    
    @GetMapping("/user/{userId}")
    public Result<List<RecommendationDTO>> getRecommendations(@PathVariable Integer userId);
    
    @GetMapping("/popular")
    public Result<List<BookDTO>> getPopularBooks();
    
    @GetMapping("/latest")
    public Result<List<BookDTO>> getLatestBooks();
    
    @PostMapping("/feedback")
    public Result<Void> recordFeedback(@RequestBody FeedbackRequest request);
}
```

## Vue前端设计（已实现）

### 1. 项目结构
```
book-recommendation-frontend/
├── src/
│   ├── main.js                    # 入口文件 ✅
│   ├── App.vue                    # 根组件 ✅
│   ├── router/index.js            # 路由配置 ✅
│   ├── stores/user.js             # 用户状态管理 ✅
│   ├── views/                     # 页面组件 ✅
│   │   ├── Home.vue              # 首页 ✅
│   │   ├── Login.vue             # 登录页 ✅
│   │   ├── Register.vue          # 注册页 ✅
│   │   ├── BookList.vue          # 图书列表 ✅
│   │   ├── BookDetail.vue        # 图书详情 ✅
│   │   ├── Profile.vue           # 个人中心 ✅
│   │   └── Recommendations.vue   # 推荐页面 ✅
│   ├── components/                # 公共组件 ✅
│   │   ├── BookCard.vue          # 图书卡片 ✅
│   │   └── Header.vue            # 页面头部 ✅
│   ├── api/                       # API调用 ✅
│   │   ├── user.js               # 用户API ✅
│   │   └── book.js               # 图书API ✅
│   └── utils/request.js           # HTTP请求工具 ✅
├── package.json                   # 项目配置 ✅
├── vite.config.js                 # Vite配置 ✅
└── index.html                     # HTML模板 ✅
```

### 2. 已实现的核心页面

#### 用户管理界面 ✅
- **登录页面**: 用户名/密码登录，表单验证
- **注册页面**: 用户注册，密码确认，邮箱验证
- **个人中心**: 用户信息展示和编辑
- **路由守卫**: 登录状态验证

#### 图书展示界面 ✅  
- **首页**: 热门图书和最新图书展示
- **图书列表**: 分页展示，关键词搜索
- **图书详情**: 图书信息展示，评分功能预留
- **响应式设计**: 适配不同屏幕尺寸

## 推荐算法设计（已实现）

### 1. 用户协同过滤算法 ✅

**应用场景**: 推荐页面的个性化推荐
**核心思想**: 找到兴趣相似的用户，推荐他们喜欢的图书

**算法步骤**:
1. **相似用户发现**: 基于共同评分图书计算用户相似度（余弦相似度）
2. **评分预测**: 使用相似用户的评分加权预测目标用户对图书的评分
3. **Top-N推荐**: 按预测评分排序，推荐前N本图书

**性能优化**:
- 智能缓存机制：评分后异步预计算，推荐响应<1秒
- 候选筛选：只计算有共同评分的用户，避免全量计算
- 增量数据更新：启动时全量加载，后续只更新新评分

### 2. 物品协同过滤算法 ✅

**应用场景**: 图书详情页的"喜欢这本书的用户也喜欢"
**核心思想**: 基于图书评分模式相似度推荐相似图书

**算法步骤**:
1. **共同用户预筛选**: 找评分过目标图书的用户，快速筛选候选图书
2. **评分模式分析**: 计算目标图书与候选图书的评分向量余弦相似度
3. **相似图书推荐**: 按相似度排序，推荐最相似的图书

**性能优化**:
- 候选预筛选：从23万本图书筛选到几千本，计算时间从30分钟→几秒
- 批量处理：避免重复数据库查询，使用pandas分组操作
- 相似度缓存：缓存计算结果，避免重复计算

### 3. 推荐系统架构 ✅

**微服务设计**:
```
recommendation-algorithm-service/  # 算法微服务(端口5000)
├── algorithms/                   # 推荐算法实现
│   ├── collaborative_filtering.py  # 用户协同过滤 ✅
│   └── item_based_cf.py           # 物品协同过滤 ✅
├── data/data_loader.py           # 数据加载和缓存 ✅
├── utils/cache.py                # 推荐结果缓存 ✅
└── app.py                        # Flask API服务 ✅
```

**API接口设计**:
- `POST /api/recommend/user-based` - 用户协同过滤推荐
- `POST /api/recommend/similar-items` - 物品协同过滤相似图书
- `POST /api/cache/clear` - 清除用户缓存
- `POST /api/cache/precompute` - 异步预计算推荐

**集成策略**:
- SpringBoot通过HTTP调用算法服务
- 评分后自动触发缓存清理和预计算
- 降级策略：算法服务不可用时返回热门图书

## 核心问题与解决方案

### 1. 数据来源与质量问题

#### 解决方案：使用Book-Crossing数据集
- **数据集选择**: Book-Crossing数据集
- **数据获取**: 从多个镜像网站下载（BX-CSV-Dump.zip）
- **数据规模**: 27万用户，27万图书，110万评分
- **数据格式**: CSV文件，包含评分、图书信息、用户信息三个文件
- **优势**: 经典推荐系统数据集、格式标准、研究广泛使用

### 2. 内容特征提取（简化方案）

#### 特征选择
- **图书作者**: 作者名称LabelEncoder编码  
- **出版年份**: 出版年份作为数值特征
- **出版社**: 出版社LabelEncoder编码
- **图书标题**: 标题文本TF-IDF向量化（使用sklearn）
- **评分统计**: 从评分数据统计平均评分和评分数量

#### 实现方案
```python
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

class BookCrossingFeatureExtractor:
    def __init__(self):
        self.tfidf = TfidfVectorizer(max_features=1000, stop_words='english')
        self.author_encoder = LabelEncoder()
        self.publisher_encoder = LabelEncoder()
        self.is_fitted = False
    
    def fit(self, books_data):
        """预训练特征提取器 - 适配Book-Crossing格式"""
        # 训练作者编码器
        authors = books_data['Book-Author'].fillna('Unknown').tolist()
        self.author_encoder.fit(authors)
        
        # 训练出版社编码器
        publishers = books_data['Publisher'].fillna('Unknown').tolist()
        self.publisher_encoder.fit(publishers)
        
        # 训练TF-IDF向量化器
        titles = books_data['Book-Title'].fillna('').tolist()
        self.tfidf.fit(titles)
        
        self.is_fitted = True
    
    def extract_features(self, book_data):
        """提取单本图书的特征向量"""
        if not self.is_fitted:
            raise ValueError("Feature extractor not fitted")
        
        features = []
        
        # 作者特征
        author = book_data.get('Book-Author', 'Unknown')
        author_encoded = self.author_encoder.transform([author])[0]
        features.append(author_encoded)
        
        # 出版年份特征
        year = book_data.get('Year-Of-Publication', 2000)
        try:
            year = int(year)
            if year < 1900 or year > 2023:
                year = 2000
        except:
            year = 2000
        features.append(year)
        
        # 出版社特征
        publisher = book_data.get('Publisher', 'Unknown')
        publisher_encoded = self.publisher_encoder.transform([publisher])[0]
        features.append(publisher_encoded)
        
        # 标题TF-IDF特征
        title = book_data.get('Book-Title', '')
        title_features = self.tfidf.transform([title]).toarray()[0]
        
        # 组合所有特征
        all_features = np.concatenate([
            features,
            title_features
        ])
        
        return all_features
```
```

### 3. 数据预处理方案

#### Book-Crossing数据清洗步骤
1. **评分数据过滤**：
   - 保留显式评分（1-10），去除隐式评分（0）
   - 将评分范围归一化到1-5分
   - 过滤活跃用户（至少评分5本书）
   - 过滤热门图书（至少被3个用户评分）

2. **图书数据清洗**：
   - 处理缺失的作者、标题、出版年份信息
   - 标准化出版年份格式
   - 清理异常的出版年份数据

3. **用户数据处理**：
   - 年龄信息标准化
   - 地理位置信息提取

## 内容过滤算法实现
    def __init__(self, n_recommendations=10):
        self.n_recommendations = n_recommendations
        self.feature_extractor = AmazonBookFeatureExtractor()
        self.book_features = {}
        self.books_data = None
    
    def fit(self, books_data, ratings_data):
        """训练基于内容的推荐模型 - 适配Amazon格式"""
        self.books_data = books_data
        
        # 训练特征提取器
        self.feature_extractor.fit(books_data)
        
        # 为所有图书提取特征
        for book in books_data:
            book_id = book.get('asin') or book.get('parent_asin')
            if book_id:
                features = self.feature_extractor.extract_features(book)
                self.book_features[book_id] = features
    
    def get_book_similarity(self, book_id1, book_id2):
        """计算两本图书的相似度"""
        if book_id1 not in self.book_features or book_id2 not in self.book_features:
            return 0.0
        
        features1 = self.book_features[book_id1].reshape(1, -1)
        features2 = self.book_features[book_id2].reshape(1, -1)
        
        similarity = cosine_similarity(features1, features2)[0][0]
        return similarity
    
    def recommend(self, user_id, user_ratings):
        """为用户生成基于内容的推荐"""
        # 获取用户评过分的图书
        user_books = [(book_id, rating) for book_id, rating in user_ratings.items() if rating > 0]
        
        if not user_books:
            # 新用户：返回随机推荐
            book_ids = list(self.book_features.keys())
            return [(book_id, 3.0) for book_id in np.random.choice(book_ids, min(self.n_recommendations, len(book_ids)), replace=False)]
        
        # 计算用户的内容偏好
        recommendations = {}
        
        for candidate_book_id in self.book_features.keys():
            if candidate_book_id in [book_id for book_id, _ in user_books]:
                continue  # 跳过用户已评分的图书
            
            # 计算与用户喜欢图书的相似度
            similarity_scores = []
            for user_book_id, rating in user_books:
                similarity = self.get_book_similarity(candidate_book_id, user_book_id)
                # 用评分加权相似度
                weighted_similarity = similarity * (rating / 5.0)  # 假设评分范围1-5
                similarity_scores.append(weighted_similarity)
            
            # 平均相似度作为推荐分数
            if similarity_scores:
                avg_similarity = np.mean(similarity_scores)
                recommendations[candidate_book_id] = avg_similarity
        
        # 排序并返回推荐结果
        sorted_recommendations = sorted(recommendations.items(), key=lambda x: x[1], reverse=True)
        return sorted_recommendations[:self.n_recommendations]
```

### 3. 算法融合策略（简化版）

#### 简单加权平均
```python
# 混合推荐算法
def hybrid_recommend(user_id, ratings_data, books_data, cf_weight=0.6, cb_weight=0.4):
    # 初始化模型
    cf_model = UserBasedCF()
    cf_model.fit(ratings_data)
    
    cb_model = ContentBasedRecommender()
    cb_model.fit(books_data, ratings_data)
    
    # 获取用户评分历史
    user_ratings = ratings_data[ratings_data['user_id'] == user_id]
    user_rating_dict = dict(zip(user_ratings['book_id'], user_ratings['rating']))
    
    # 协同过滤推荐
    cf_recommendations = cf_model.recommend(user_id)
    cf_scores = {book_id: score for book_id, score in cf_recommendations}
    
    # 基于内容的推荐
    cb_recommendations = cb_model.recommend(user_id, user_rating_dict)
    cb_scores = {book_id: score for book_id, score in cb_recommendations}
    
    # 获取所有候选图书
    all_books = set(cf_scores.keys()) | set(cb_scores.keys())
    
    # 混合推荐分数
    final_scores = {}
    for book_id in all_books:
        cf_score = cf_scores.get(book_id, 0)
        cb_score = cb_scores.get(book_id, 0)
        
        # 加权融合
        final_score = cf_weight * cf_score + cb_weight * cb_score
        final_scores[book_id] = final_score
    
    # 排序并返回推荐结果
    sorted_recommendations = sorted(final_scores.items(), key=lambda x: x[1], reverse=True)
    return sorted_recommendations[:10]
```

#### 权重设置
- 协同过滤权重: 0.6
- 内容特征权重: 0.4
- 固定权重，简单有效

### 4. 评价指标（使用sklearn）

#### 评估方法
```python
from sklearn.metrics import precision_score, recall_score, f1_score
from sklearn.model_selection import train_test_split
import numpy as np

# 评估函数
def evaluate_recommendations(y_true, y_pred, k=10):
    # 取前k个推荐
    top_k_pred = y_pred[:k]
    
    # 计算精确率和召回率
    precision = len(set(y_true) & set(top_k_pred)) / k
    recall = len(set(y_true) & set(top_k_pred)) / len(y_true)
    
    # F1分数
    f1 = 2 * precision * recall / (precision + recall) if (precision + recall) > 0 else 0
    
    return precision, recall, f1

# 交叉验证
def cross_validate(data, algorithm, k_folds=5):
    from sklearn.model_selection import KFold
    kf = KFold(n_splits=k_folds)
    
    precisions, recalls, f1s = [], [], []
    
    for train_idx, test_idx in kf.split(data):
        train_data = data.iloc[train_idx]
        test_data = data.iloc[test_idx]
        
        # 训练模型并评估
        model = algorithm.fit(train_data)
        predictions = model.predict(test_data)
        
        p, r, f = evaluate_recommendations(test_data['actual'], predictions)
        precisions.append(p)
        recalls.append(r) 
        f1s.append(f)
    
    return np.mean(precisions), np.mean(recalls), np.mean(f1s)
```

#### 对比实验
1. **协同过滤算法**
2. **基于内容的推荐**  
3. **混合推荐算法**
4. **随机推荐（基线）**

## Python与Java数据交互设计

### 架构方案：微服务分离

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Vue前端       │    │  SpringBoot     │    │  Python算法服务  │
│                 │◄──►│   Web服务       │◄──►│                 │
│ - 用户界面      │    │ - REST API      │    │ - 协同过滤      │
│ - 推荐展示      │    │ - 业务逻辑      │    │ - 内容特征      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │                        │
                                ▼                        ▼
                        ┌─────────────────┐    ┌─────────────────┐
                        │   MySQL数据库    │    │  算法结果缓存    │
                        │ - 用户数据      │    │   (Redis)       │
                        │ - 图书数据      │    └─────────────────┘
                        │ - 评分数据      │
                        └─────────────────┘
```

### 数据交互流程

#### 1. 数据同步策略
```python
# Python算法服务数据访问
import pymysql
import pandas as pd

class DataConnector:
    def __init__(self):
        self.db_config = {
            'host': 'localhost',
            'user': 'root',
            'password': 'password',
            'database': 'book_recommend',
            'charset': 'utf8mb4'
        }
    
    def get_ratings_data(self):
        """获取评分数据用于训练算法"""
        sql = """
        SELECT user_id, book_id, rating, created_time 
        FROM user_ratings 
        WHERE rating > 0
        """
        conn = pymysql.connect(**self.db_config)
        df = pd.read_sql(sql, conn)
        conn.close()
        return df
    
    def save_recommendations(self, user_id, recommendations):
        """保存推荐结果到数据库"""
        conn = pymysql.connect(**self.db_config)
        cursor = conn.cursor()
        
        # 先删除旧推荐
        cursor.execute("DELETE FROM user_recommendations WHERE user_id = %s", (user_id,))
        
        # 插入新推荐
        for rank, (book_id, score) in enumerate(recommendations, 1):
            cursor.execute("""
                INSERT INTO user_recommendations (user_id, book_id, score, rank, created_time)
                VALUES (%s, %s, %s, %s, NOW())
            """, (user_id, book_id, score, rank))
        
        conn.commit()
        conn.close()
```

#### 2. SpringBoot调用Python服务
```java
@RestController
@RequestMapping("/api/recommend")
public class RecommendController {
    
    @Autowired
    private PythonAlgorithmService pythonService;
    
    @GetMapping("/user/{userId}")
    public ResponseEntity<List<BookRecommendDTO>> getUserRecommendations(@PathVariable Long userId) {
        // 1. 调用Python算法服务
        pythonService.generateRecommendations(userId);
        
        // 2. 从数据库获取推荐结果
        List<BookRecommendDTO> recommendations = recommendService.getRecommendations(userId);
        
        return ResponseEntity.ok(recommendations);
    }
}

@Service
public class PythonAlgorithmService {
    
    public void generateRecommendations(Long userId) {
        RestTemplate restTemplate = new RestTemplate();
        String pythonServiceUrl = "http://localhost:5000/recommend/" + userId;
        restTemplate.postForObject(pythonServiceUrl, null, String.class);
    }
}
```

#### 3. Python Flask算法服务
```python
from flask import Flask, jsonify

app = Flask(__name__)

# 全局模型变量
cf_model = None
cb_model = None
data_connector = None

def initialize_models():
    """初始化和训练推荐模型"""
    global cf_model, cb_model, data_connector
    
    data_connector = DataConnector()
    ratings_data = data_connector.get_ratings_data()
    books_data = data_connector.get_book_features()
    
    # 训练协同过滤模型
    cf_model = UserBasedCF()
    cf_model.fit(ratings_data)
    
    # 训练基于内容的推荐模型
    cb_model = ContentBasedRecommender()
    cb_model.fit(books_data, ratings_data)

@app.route('/recommend/<int:user_id>', methods=['POST'])
def generate_recommendations(user_id):
    """为指定用户生成推荐"""
    try:
        # 获取用户评分历史
        user_ratings = data_connector.get_user_ratings(user_id)
        
        # 使用混合推荐算法
        recommendations = hybrid_recommend(
            user_id, 
            data_connector.get_ratings_data(),
            data_connector.get_book_features()
        )
        
        # 保存结果到数据库
        data_connector.save_recommendations(user_id, recommendations)
        
        return jsonify({"status": "success", "count": len(recommendations)})
    
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/retrain', methods=['POST'])
def retrain_models():
    """重新训练推荐模型"""
    try:
        initialize_models()
        return jsonify({"status": "success", "message": "模型重新训练完成"})
    
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

if __name__ == '__main__':
    # 启动时训练模型
    initialize_models()
    app.run(host='0.0.0.0', port=5000)
```

### 数据库表设计

```sql
-- 用户推荐结果表
CREATE TABLE user_recommendations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    book_id BIGINT NOT NULL,
    score DECIMAL(5,4) NOT NULL,
    rank INT NOT NULL,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_rank (user_id, rank)
);
```

## 技术架构

### 核心技术栈
- **后端框架**: SpringBoot 3.x
- **安全框架**: Spring Security
- **数据访问**: JPA/MyBatis-Plus
- **前端框架**: Vue 3
- **UI组件**: ElementPlus/Ant Design Vue
- **HTTP客户端**: Axios
- **数据库**: MySQL 8.0
- **缓存**: Redis
- **推荐算法**: Python自研算法服务

### 推荐算法策略
1. **协同过滤**: 基于用户-物品评分矩阵的用户相似度计算
2. **内容特征**: 基于图书标签、分类、作者等特征的相似度匹配
3. **混合推荐**: 加权融合两种算法结果

## 系统架构设计

### 协同过滤算法设计
- **用户基协同过滤(User-CF)**: 计算用户相似度，推荐相似用户喜欢的图书
- **物品基协同过滤(Item-CF)**: 计算图书相似度，推荐与用户历史借阅相似的图书

### 内容特征推荐算法
- **TF-IDF**: 提取图书描述、标签的关键词特征
- **余弦相似度**: 计算图书内容向量相似度
- **标签匹配**: 基于分类、作者、出版社等元数据匹配

### SpringBoot后端架构
```
src/main/java/com/library/recommend/
├── controller/     # REST API控制层
├── service/        # 业务逻辑层
├── repository/     # 数据访问层
├── entity/         # 实体类
├── dto/           # 数据传输对象
├── config/        # 配置类
└── utils/         # 工具类
```

#### 核心模块
- **RecommendController**: 推荐接口
- **PythonAlgorithmService**: Python算法服务调用
- **UserBehaviorService**: 用户行为数据收集
- **BookService**: 图书信息管理

### Vue前端架构
```
src/
├── components/     # 通用组件
├── views/         # 页面组件
├── api/           # API接口封装
├── store/         # Vuex状态管理
├── router/        # 路由配置
├── utils/         # 工具函数
└── assets/        # 静态资源
```

#### 核心页面
- **BookList**: 图书列表与搜索
- **BookDetail**: 图书详情
- **Recommend**: 个性化推荐页面
- **UserProfile**: 用户个人中心
- **Dashboard**: 管理后台

## 数据库设计

### 主要数据表
- **用户表(users)**: user_id, username, password, email, preferences, created_at
- **图书表(books)**: book_id, title, author, category, isbn, description, publish_date, publisher
- **评分表(ratings)**: rating_id, user_id, book_id, rating, timestamp
- **借阅记录表(borrow_records)**: record_id, user_id, book_id, borrow_date, return_date, status
- **图书特征表(book_features)**: feature_id, book_id, features(JSON), tags
- **用户行为表(user_behaviors)**: behavior_id, user_id, book_id, action_type, timestamp

### 索引设计
- user_id, book_id的联合索引
- category, author的单独索引
- 时间字段的索引优化


## 性能优化方案

### 缓存策略
- **Redis缓存**: 热门推荐结果、用户相似度矩阵
- **本地缓存**: 图书特征向量、频繁访问数据
- **缓存更新**: 定时任务 + 增量更新

### 异步处理
- 用户行为数据异步写入
- 推荐模型后台定时更新
- 大数据量计算使用线程池

### 数据库优化
- 读写分离
- 分库分表策略
- 索引优化

## 预期成果
1. 完整的推荐系统demo
2. 算法对比实验报告
3. 本科毕业论文
4. 系统使用说明文档

**详细实施计划请参考**: `docs/项目实施计划.md`

---

**版本**: v1.0  
**创建时间**: 2025-09-20  
**负责人**: 开发团队  
**更新记录**: 初始版本